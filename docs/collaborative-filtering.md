# 协同过滤推荐算法说明

本文档介绍 `backend` 模块中 `RecommendationService` 所实现的景区推荐能力，帮助开发者快速理解算法逻辑、数据依赖与可扩展点。

## 总体思路

当前系统采用 **“用户-用户” 协同过滤**（User-Based Collaborative Filtering，UBCF）为核心，并辅以 **标签画像打分** 与 **热门兜底** 机制，确保即使在用户历史较少的情况下也能返回可用结果。整个流程如下：

1. **加载当前用户访问记录**：通过 `UserVisitHistoryRepository.findByUserId` 拉取该用户的景点评分与访问时间。
2. **若无历史直接兜底**：调用 `fallbackPopularSpots()` 返回近期访问热度最高的景点。
3. **构建访问集合与标签画像**：统计已访问景点 ID 集合，以及对这些景点的标签权重（评分 + 时序加权）。
4. **寻找相似用户**：检索访问过相同景点的其他用户，计算余弦相似度，筛出相似度 ≥ `0.1` 的用户，最多保留 `8` 位。
5. **生成候选评分**：遍历相似用户尚未被当前用户访问的景点，按照 “相似度 × (评分权重 + 时间衰减)” 进行累积打分。
6. **标签加分**：根据当前用户的标签偏好，对所有未访问景点进行标签得分，再以 `0.75` 的系数合并到候选集合。
7. **排序截断**：按最终得分倒序取前 `10` 条，若为空则再次回退到热门景点。

## 关键数据来源

| 数据 | 说明 | 主要用途 |
| --- | --- | --- |
| `UserVisitHistory` | 用户访问记录（景点、评分、访问时间） | 相似度计算、评分权重、时间衰减 |
| `SpotTag` | 景点标签（如自然、人文、亲子等） | 构建用户标签画像、标签打分 |
| `ScenicSpot` | 景点实体 | 将候选 ID 转换为完整实体 |

> 若需要扩展画像维度，可在 `SpotTag` 或新增表中管理更多标签/属性，再在 `buildUserTagProfile` 中引入权重。

## 相似度算法

- **评分向量**：使用 `toRatingMap` 将访问记录转成 `{spotId -> rating}` 的 Map。
- **余弦相似度**：只对两个用户共同访问过的景点计算 `cosine(user1, user2)`。
- **降噪策略**：
  - 若无交集或任一用户向量模为 0，则相似度记为 0。
  - 小于 `MIN_SIMILARITY (0.1)` 的用户直接过滤，避免引入噪音。

## 评分与时间衰减

- `normalizeRating`：将 rating 为空的情况默认成 `3` 分，保持评分向量稳定。
- `calculateRecencyBoost`：以 `180` 天为窗口，线性衰减，越近期的访问越能提升推荐得分。
- 候选得分公式（简化）：
  ```
  candidateScore(spot) += similarity(simUser, currentUser) *
                          (normalizeRating(history.rating) + recencyBoost(history.visitDate))
  ```

## 标签画像与 Tag-Based Scoring

1. `buildUserTagProfile`
   - 聚合当前用户访问过的景点标签，权重 = 评分权重 + 时间衰减。
   - 构建 `{tagValue -> weight}` 的画像。
2. `scoreSpotsByTags`
   - 遍历所有景点（可改为只遍历启用/上线景点以降低成本）。
   - 对未访问景点的标签进行权重求和，若结果 > 0，则放入候选集合。
3. `TAG_SCORE_MULTIPLIER (0.75)`：控制标签分对最终得分的影响，避免标签分完全盖过协同过滤分。

## 热门兜底策略

`fallbackPopularSpots`

- 若用户完全没有历史、或协同过滤结果为空，则启用热门兜底。
- 统计所有历史记录的 “评分 + 时间衰减” 总和，作为景点热度，并按降序取前 `MAX_RESULTS`。
- 若数据表为空，再退化为 `spotRepository.findAll().limit(MAX_RESULTS)`。

## 可配置常量

常量集中定义在 `RecommendationService` 顶部，可视业务情况调整：

| 常量 | 默认值 | 作用 |
| --- | --- | --- |
| `MAX_SIMILAR_USERS` | `8` | 控制相似用户的数量上限 |
| `MAX_RESULTS` | `10` | 推荐列表长度 |
| `MIN_SIMILARITY` | `0.1` | 相似用户阈值 |
| `RECENCY_WINDOW_DAYS` | `180` | 时间衰减窗口 |
| `DEFAULT_RATING` | `3` | 缺省评分 |
| `TAG_SCORE_MULTIPLIER` | `0.75` | 标签打分权重 |

## 扩展建议

### 引入点击次数与浏览时长

如果前端或埋点系统能够统计「用户点击景点卡片的次数」及「在景点详情页的停留时长」，可以将这些弱反馈行为转化为附加权重，增强画像与候选得分。

1. **数据落盘**：在 `UserVisitHistory` 或新建 `UserEngagement` 表中存储 `clickCount`、`dwellSeconds`，并确保有 `visitDate` 方便时间衰减。
2. **行为标准化**：
   - 设定点击与浏览权重系数，例如 `clickWeight = log(1 + clickCount)`，`dwellWeight = min(dwellSeconds / 60, 5)`。
   - 将系数与原有评分加权求和，统一传入 `normalizeRating`/`calculateRecencyBoost` 逻辑，避免尺度不一致。
3. **画像加权**：在 `buildUserTagProfile` 中，把行为权重叠加到标签分（如 `baseWeight + clickWeight + dwellWeight`），使经常查看的标签得到更高偏好值。
4. **候选得分**：在相似用户候选循环中，把这些行为权重带入累积分数，或单独在 `scoreSpotsByTags` 后叠加一个 `engagementScore`.
5. **调试输出**：沿用 `RecommendationDebugResponse`，新增字段展示行为权重，便于观察调整效果。

这样可以兼顾显性评分与隐性反馈，尤其对未评分但频繁浏览的景点更敏感，提升推荐点击率。

### 多路召回与重排

- **召回阶段**：在现有 UserCF + Tag 分数之外，增加热门主题、距离、活动等多种召回；各自只负责产出候选集合。
- **粗排/重排**：把多路候选合并后，再由统一的打分函数（可继续沿用当前的协同 + 标签得分）进行排序，或引入轻量模型（如 GBDT）。
- **灵活配置**：通过配置表控制每条召回的开启、阈值和上限，便于 A/B。

### 冷启动与画像补全

- **新用户冷启动**：引导用户选偏好标签、行程目的或旅伴类型，把问卷结果直接注入 `tagProfile`，避免全靠热门兜底。
- **新景点冷启动**：对新上架景点可参考运营打分或相似景点的标签画像，提前赋予基础标签权重，让其更容易被召回。

### 多样性与探索

- **相似度去重**：限制同一城市/类型的景点在 Top-N 中的占比，防止结果过于集中。
- **ε-Greedy**：在排序结果中预留少量位置给随机或低曝光景点，用于探索用户潜在兴趣，并回流行为数据。

### 实时/增量更新

- **事件驱动刷新**：在用户产生访问/评分后，异步刷新其画像缓存，降低下一次查询的延迟。
- **批量缓存**：对高频用户或热门景点预先计算相似度和标签分，放入 Redis，若数据过期再懒加载计算。

- **混合召回**：引入基于内容（Content-Based）的初筛，再交给 CF 排序。
- **打分归一化**：将评分/时间权重归一化为 [0,1]，避免不同尺度混杂。
- **时空过滤**：结合用户当前位置或行程偏好，对候选景点做距离过滤。
- **缓存与离线计算**：对高频用户或热门景点的相似度分布进行缓存，降低实时计算压力。
- **AB 实验**：为不同策略设置开关，并结合用户留存/点击率监控效果。

如需进一步升级，可考虑在 `RecommendationService` 外层封装 `RecommendationPipeline`，将召回、排序、重排等步骤模块化，便于插拔更多算法组件。


